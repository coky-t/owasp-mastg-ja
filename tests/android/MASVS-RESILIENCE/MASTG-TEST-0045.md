---
masvs_v1_id:
- MSTG-RESILIENCE-1
masvs_v2_id:
- MASVS-RESILIENCE-1
platform: android
title: ルート検出のテスト (Testing Root Detection)
masvs_v1_levels:
- R
---

## ルート検出のバイパス

jdb, [DDMS](https://developer.android.com/studio/profile/monitor "DDMS"), `strace`, カーネルモジュールを使用して実行トレースを実行し、アプリが何を行っているかを確認します。通常、プロセスのリストを読み込んだり取得するために `su` をオープンするなど、オペレーティングシステムとのあらゆる種類の疑わしいやり取りがみられるでしょう。これらのやり取りはルート検出の確実な兆候です。ルート検出メカニズムを一つずつ特定して無効にします。ブラックボックスでの耐性評価を実施するのであれば、ルート検出メカニズムを無効にすることが最初のステップです。

これらのチェックをバイパスするには、いくつかの技法を使用できます。そのほとんどは "リバースエンジニアリングと改竄" の章で紹介されています。

- バイナリの名前を変更します。たとえば、場合によっては単に `su` バイナリの名前を変更するだけで、ルート検出を回避できることがあります (ただし、環境を壊さないようにしましょう！) 。
- `/proc` をアンマウントしてプロセスリストの読み取りを防ぎます。場合によっては `/proc` が利用できないだけで、そのようなチェックをバイパスできることがあります。
- Frida か Xposed を使用して、Java とネイティブ層の API をフックします。これはファイルとプロセスを隠し、ファイルのコンテンツを隠し、アプリが要求するあらゆる種類の偽の値を返します。
- カーネルモジュールを使用して、低レベル API をフックします。
- アプリにパッチを適用して、チェックと外します。

## 有効性評価

ルート検出メカニズムをチェックするには、以下のような基準があります。

- 複数の検出手法がアプリ全体に散在しています (すべてを一つの手法にまとめてはいません) 。
- ルート検出メカニズムは複数の API レイヤ (Java API、ネイティブライブラリ関数、アセンブラ/システムコール) で動作します。
- メカニズムはどうやらオリジナルである (StackOverflow や他のソースからコピー＆ペーストしてはいません) 。

ルート検出メカニズムのバイパス手法を開発し、以下の質問に回答します。

- RootCloak などの標準ツールを使用してそのメカニズムを簡単にバイパスできますか？
- ルート検出を処理するために静的/動的解析が必要ですか？
- カスタムコードを書く必要がありますか？
- そのメカニズムのバイパスに成功するまでにどれくらいの時間がかかりましたか？
- そのメカニズムをバイパスすることの難しさをどのように評価しますか？

ルート検出が見当たらない場合や非常に簡単にバイパスできる場合には、上記の有効性基準に沿って提案を行います。これらの提案にはより多くの検出メカニズムや、既存のメカニズムと他の防御策とのより適切な統合などがあるかもしれません。
