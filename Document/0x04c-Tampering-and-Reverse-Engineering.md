## 改竄とリバースエンジニアリング

リバースエンジニアリングや改竄の技法は長い間、クラッカー、MOD作成者、マルウェア解析者などの分野に属していました。「伝統的な」セキュリティテスト技術者や研究者にとって、リバースエンジニアリングはどちらかというと補完的なスキルでした。しかし状況は一変します。モバイルアプリのブラックボックステストではコンパイルされたアプリを逆アセンブルし、パッチを適用し、バイナリコードやライブプロセスを改竄することがますます必要になっています。多くのモバイルアプリが歓迎されない改竄に対する防御を実装しているという事実はセキュリティテスト技術者にとって物事を簡単にしてはくれません。

モバイルアプリのリバースエンジニアリングはコンパイルされたアプリを解析するプロセスであり、そのソースコードに関する情報を抽出します。リバースエンジニアリングの目的はコードを *理解すること* です。

*改竄* はモバイルアプリ (コンパイルされたアプリまたは実行中のプロセス) またはその動作に影響を与える環境を変更するプロセスです。例えば、アプリはルート化されたテストデバイス上で実行することを拒む可能性があり、一部のテストを実行できなくなる可能性があります。そのような場合には、アプリの動作を変更したいでしょう。

モバイルセキュリティテスト技術者を上手く務めるには基本的なリバースエンジニアリングの概念を理解することが必要です。モバイルデバイスやオペレーティングシステムも十分に知る必要があります。プロセッサアーキテクチャ、実行形式、プログラミング言語の錯綜などがあります。

リバースエンジニアリングは芸術であり、そのすべてのファセットを記述することはライブラリ全体を占めるでしょう。技術と専門化の幅広い領域は驚異的です。マルウェア解析の自動化や新しい逆難読化手法の開発など、非常に特殊で独立した部分問題の取り組みに何年も費やすことがあります。セキュリティテスト技術者はジェネラリストです。有能なリバースエンジニアであるためには、膨大な量の関連情報をフィルタする必要があります。

常に機能する一般的なリバースエンジニアリングプロセスはありません。それでは、よく使われる手法やツールについてこのガイドで後ほど説明し、最も一般的な防御に取り組む例を挙げましょう。

### あなたがそれを必要とする理由

モバイルセキュリティテストにはいくつかの理由から少なくとも基本的なリバースエンジニアリングのスキルが必要です。

**1. モバイルアプリのブラックボックステストを可能にするため。** 現在のアプリには動的解析を妨げるコントロールを含むことがよくあります。SSL ピンニングとエンドツーエンド (E2E) 暗号化によりプロキシを使用したトラフィックの傍受や操作が妨げられることがあります。ルート検出はアプリがルート化されたデバイス上で実行できなくなり、高度なテストツールを使用できなくなる可能性があります。これらの防御を無効にする必要があります。

**2. ブラックボックスセキュリティテストの静的解析を強化するため。** ブラックボックステストでは、アプリバイトコードやバイナリコードの静的解析はアプリの内部ロジックを理解するのに役立ちます。また、ハードコードされた資格情報などの欠陥を識別することもできます。

**3. リバースエンジニアリングに対する耐性を評価するため。** モバイルアプリケーション検証標準のアンチリバースコントロール (MASVS-R) にリストされているソフトウェア保護対策を実装するアプリはある程度のリバースエンジニアリングに対して耐性を持つ必要があります。それぞれのコントロールの有効性を検証するには、テスト担当者は一般的なセキュリティテストの一部として *耐性評価* を実行します。耐性評価では、テスト担当者はリバースエンジニアの役割を引き受け、防御のバイパスを試みます。

モバイルアプリのリバーシングの世界に飛び込む前に、良いニュースと悪いニュースを共有します。良いニュースから始めましょう。

**最終的に、リバースエンジニアは常に勝利します。**

これはモバイルの世界では特に真実です。リバースエンジニアは本質的な利点を持っています。モバイルアプリをデプロイおよびサンドボックス化する方法は従来のデスクトップアプリのデプロイメントやサンドボックス化よりも設計上の制約があります。そのため Windows ソフトウェアでよく見られるルートキットのような防御メカニズムを含めること (DRM システムなど) は簡単には実行できません。Android のオープン性によりリバースエンジニアはオペレーティングシステムに有利な変更を加え、リバースエンジニアリングプロセスを支援することを可能にします。iOS ではリバースエンジニアはほとんどコントロールできませんが、防御の選択肢もまた制限されています。

悪いニュースとしては、マルチスレッドでのアンチデバッグコントロール、暗号化ホワイトボックス、隠れた耐タンパ性機能、非常に複雑なコントロールフロー変換を扱うことは容易ではないということです。最も効果的なソフトウェア保護スキームは独自のものであり、標準の微調整やトリックで太刀打ちできないでしょう。それらを打ち破るには、面倒な手動解析、コーディング、フラストレーション、そして - あなたの性格によっては - 眠れない夜と緊張状態の関係が要求されます。

初心者にとってリバーシングの膨大な範囲に圧倒されてしまうことはよくあります。始める際の最善の方法はいくつかの基本的なツール (Android および iOS のリバーシングの章の関連するセクションを参照) をセットアップし、簡単なリバーシングタスクや crackme を開始することです。アセンブラやバイトコード言語、オペレーティングシステム、難読化などに遭遇し学ぶ必要があるでしょう。簡単なタスクから始めて、より難しいものへ徐々にレベルアップしていきます。

以下のセクションでは、モバイルアプリのセキュリティテストで最もよく使用される技法の概要を説明します。以降の章では、Android と iOS の両方について OS 固有の詳細を掘り下げていきます。

### 基本的な改竄技法

#### バイナリパッチ適用

*パッチ適用* とはコンパイルされたアプリを変更するプロセスです。バイナリ実行形式のコード変更、Java バイトコードの改変、リソースの改竄などがあります。このプロセスはモバイルゲームのハッキングシーンで *MOD適用* として知られています。パッチは多くの方法で適用できます。16進エディタでのバイナリファイルの編集やアプリの逆コンパイル、編集、逆アセンブルなどがあります。有用なパッチの詳細な例について以降の章で説明します。

心に留めておくものとして、現在のモバイルオペレーティングシステムはコード署名を厳しく強制することがあります。そのため、改変されたアプリを実行することはデスクトップ環境で使用するほど簡単ではありません。セキュリティ専門家は90年代にははるかに簡単な人生を送っていました。幸運なことに、あなた自身のデバイスで作業する場合、パッチ適用はそれほど難しいことではありません。つまり、改変したコードを実行するには、アプリを再署名するか、デフォルトのコード署名検証機能を無効にする必要があるというだけです。

#### コードインジェクション

コードインジェクションは非常に強力な技法であり、実行時にプロセスを探索および改変できます。インジェクションはさまざまな方法で実装されますが、自由に利用でき十分に文書化されたプロセスを自動化するツールのおかげで、すべての詳細を知らなくても使用できます。これらのツールは、アプリによりインスタンス化されたライブオブジェクトなどの、プロセスメモリや重要な構造体に直接アクセスできます。また、ロードされたライブラリの解決、メソッドやネイティブ関数のフックなどに役立つ多くのユーティリティ関数があります。プロセスメモリの改竄はファイルにパッチを適用するよりも検出が難しく、大半の場合に推奨される方法です。

Substrate, Frida, Xposed はモバイル業界で最も広く使用されているフックとコードインジェクションのフレームワークです。三つのフレームワークは設計の哲学と実装の詳細が異なります。Substrate と Xposed はコードインジェクションやフックに焦点を当てています。一方、Frida は本格的な「動的計装フレームワーク」とすることを目指しており、コードインジェクション、言語バインディング、インジェクト可能な JavaScript VM およびコンソールを組み込んでいます。

それだけでなく、Cycript をインジェクトするために Substrate を使用してアプリを計装することもできます。Cycript は Cydia で有名な Saurik が作成したプログラミング環境 (通称 "Cycript-to-JavaScript" コンパイラ) です。さらに物事は複雑になりますが、Frida の作者も ["frida-cycript"](https://github.com/nowsecure/frida-cycript "Cycript fork powered by Frida") と呼ばれる Cycript のフォークを作成しました。これは Cycript のランタイムを Mjølner と呼ばれる Frida ベースのランタイムに置き換えます。これにより frida-core で保守されているすべてのプラットフォームとアーキテクチャで Cycript を実行できます (この時点で混乱しても、心配ありません) 。frida-cycript のリリースには Frida の開発者 Ole によるブログ記事 "Cycript on Steroids" が付いていました。このタイトルは [Saurik はあまり好きではありませんでした](https://www.reddit.com/r/ReverseEngineering/comments/50uweq/cycript_on_steroids_pumping_up_portability_and/ "Cycript on steroids: Pumping up portability and performance with Frida") 。

三つすべてのフレームワークについて例を紹介します。私たちは Frida で始めることをお勧めします。これは三つの中で最も汎用性が高いからです (このため、Frida の詳細と事例が多く紹介されています) 。特に、Frida は Android と iOS の両方のプロセスに JavaScript VM をインジェクトできます。一方で Substrate での Cycript インジェクションは iOS でのみ動作します。しかし最終的には、いずれのフレームワークでも多くの同じ目標に到達できます。

##### Frida

[Frida](https://www.frida.re "Frida") は Ole André Vadla Ravnås により Vala で書かれたフリーでオープンソースの動的コード計装ツールキットです。JavaScript エンジン ([Duktape](https://duktape.org/ "Duktape JavaScript Engine") および [V8](https://v8.dev/docs "V8 JavaScript Engine")) を計装化プロセスにインジェクトすることにより機能します。Frida では Android や iOS (および [その他のプラットフォーム](https://www.frida.re/docs/home/ "So what is Frida, exactly?")) のネイティブアプリ内で JavaScript のスニペットを実行することができます。

コードはいくつかの方法でインジェクトできます。例えば、Xposed は Android アプリローダーを恒久的に改変し、新しいプロセスが開始されるたびに独自のコードを実行するフックを提供します。
対照的に、Frida は直接プロセスメモリにコードを書くことでコードインジェクションを実装しています。実行中のアプリにアタッチされている場合には、

- Frida は実行中プロセスのスレッドをハイジャックするために ptrace を使用します。このスレッドはメモリのチャンクを割り当てるために使用され、それにミニブートストラップを投入します。
- ブートストラップは新しいスレッドを起動し、デバイス上で実行されている Frida デバッグサーバーに接続し、Frida エージェント (`frida-agent.so`) を含む共有ライブラリをロードします。
- エージェントはツール (例えば、Frida REPL やカスタム Python スクリプト) への双方向通信チャネルを確立します。
- ハイジャックされたスレッドは元の状態に復元された後に再開し、プロセスの実行は通常どおり続行します。

<img src="Images/Chapters/0x04/frida.png" alt="Frida Architecture" width="500" />

- *Frida アーキテクチャ, 参照元: [https://www.frida.re/docs/hacking/](https://www.frida.re/docs/hacking "Frida - Hacking")*

Frida には三つの動作モードがあります。

1. Injected: これは frida-server が iOS または Android デバイスでデーモンとして実行されているときの最も一般的なシナリオです。frida-core は TCP 上で公開され、デフォルトでは localhost:27042 で待機しています。このモードでの実行はルート化されていないデバイスや脱獄されていないデバイスでは不可能です。
2. Embedded: これはあなたのデバイスがルート化や脱獄済みではない (あなたは非特権ユーザーとして ptrace を使用できない) 場合のものです。あなたにはアプリに [frida-gadget](https://www.frida.re/docs/gadget/ "Frida Gadget") ライブラリを埋め込むことによるインジェクションの責任があります。
3. Preloaded: `LD_PRELOAD` や `DYLD_INSERT_LIBRARIES` に似ています。frida-gadget を自律的に実行し、ファイルシステム (Gadget バイナリが存在する場所からの相対パスなど) からスクリプトをロードするように設定できます。

選択したモードに関係なく、[Frida JavaScript API](https://www.frida.re/docs/javascript-api/ "Frida JavaScript APIs") を使用して、実行中のプロセスとそのメモリと対話できます。基本的な API の一部を以下に示します。

- [Interceptor](https://www.frida.re/docs/javascript-api/#interceptor "Interceptor"): Interceptor API を使用する場合、Frida は関数プロローグにトランポリン (別名インラインフック) を注入し、カスタムコードへのリダイレクトを引き起こし、そのコードを実行して、元の関数に戻ります。私たちの目的には非常に効果的ですが、かなりのオーバーヘッドをもたらし (トランポリン関連のジャンプとコンテキストスイッチのため) 、元のコードを上書きしデバッガと同様に動作する (ブレークポイントを置く) ため透過的であるとはみなせず、したがって例えば定期的に自身のコードを定期的にチェックサムするアプリケーションにより、同様の方法で検出されることに注意します。
- [Stalker](https://www.frida.re/docs/javascript-api/#stalker "Stalker"): トレース要件に透明性、パフォーマンス、高粒度が含まれる場合、Stalker が選択すべき API となります。Stalker API でコードをトレースする際、Frida はジャストインタイムの動的再コンパイルを活用します ([Capstone](http://www.capstone-engine.org/ "Capstone") を使用) 。スレッドが次の命令を実行しようとすると、Stalker はメモリを割り当て、元のコードをコピーし、そのコピーをインストルメンテーション用のカスタムコードとインターレースします。最後に、そのコピーを実行します (元のコードには手を加えません。したがって、アンチデバッグチェックを回避します) 。このアプローチによりインストルメンテーションのパフォーマンスは大幅に向上し、トレース時に非常に高い粒度が可能になります (例えば CALL や RET 命令のみをトレースします) 。詳細については [Frida の作者である Ole によるブログ記事 "Anatomy of a code tracer"](https://medium.com/@oleavr/anatomy-of-a-code-tracer-b081aadb0df8 "Anatomy of a code tracer") [#vadla] で学ぶことができます。Stalker の使用例には、例えば [who-does-it-call](https://codeshare.frida.re/@oleavr/who-does-it-call/ "who-does-it-call") や [diff-calls](https://github.com/frida/frida-presentations/blob/master/R2Con2017/01-basics/02-diff-calls.js "diff-calls") があります。
- [Java](https://www.frida.re/docs/javascript-api/#java "Java"): Android 上で作業している場合、この API を使用してロードされたクラスの列挙、クラスローダーの列挙、特定のクラスインスタンスの作成および使用、ヒープをスキャンすることによるクラスのライブインスタンスの列挙などが可能です。
- [ObjC](https://www.frida.re/docs/javascript-api/#objc "ObjC"): iOS 上で作業している場合、この API を使用して登録されたすべてのクラスのマッピングの取得、特定のクラスまたはプロトコルインスタンスの登録または使用、ヒープをスキャンすることによるクラスのライブインスタンスの列挙などが可能です。

Frida は Frida API 上に構築された一連のシンプルなツール群も提供します。pip を介して frida-tools をインストールした後で端末から直接利用できます。例を示します。

- 迅速なスクリプトプロトタイピングやトライ＆エラーシナリオには [Frida CLI](https://www.frida.re/docs/frida-cli/ "Frida CLI") (`frida`) を使うことができます。
- [`frida-ps`](https://www.frida.re/docs/frida-ps/ "frida-ps") はデバイス上で実行されているすべてのアプリ (またはプロセス) の名前と PDI を含むリストを取得します。
- [`frida-ls-devices`](https://www.frida.re/docs/frida-ls-devices/ "frida-ls-devices") は接続しているデバイスを一覧表示します。
- [`frida-trace`](https://www.frida.re/docs/frida-trace/ "frida-trace") は、iOS アプリの一部であるメソッドや Android ネイティブライブラリ内で実装されているメソッドを迅速にトレースします。

さらに、Frida ベースのオープンソースツールもいくつかあります。例を示します。

- [Passionfruit](https://github.com/chaitin/passionfruit "Passionfruit"): iOS アプリのブラックボックス評価ツール。
- [Fridump](https://github.com/Nightbringer21/fridump "fridump"): Android と iOS の両方で使えるメモリダンプツール。
- [Objection](https://github.com/sensepost/objection "objection"): ランタイムモバイルセキュリティ評価フレームワーク。
- [r2frida](https://github.com/nowsecure/r2frida "r2frida"): radare2 の強力なリバースエンジニアリング機能と Frida の動的計装ツールキットをマージしたプロジェクト。
- [jnitrace](https://github.com/chame1eon/jnitrace "jnitrace"): ネイティブライブラリによる Android JNI ランタイムメソッドの使用状況をトレースするためのツール。

このガイドではこれらすべてのツールを使用していきます。

これらのツールはそのまま使用することも、ニーズに合わせて調整することも、API の使用方法に関する優れた例として使用することもできます。例としてそれらを持つことは、あなたが自身のフックスクリプトを書くときやイントロスペクションツールを構築するとき、リバースエンジニアリングワークフローをサポートするために非常に役立ちます。

もうひとつ、Frida CodeShare プロジェクト (<https://codeshare.frida.re>) について説明します。すぐに実行可能な Frida スクリプトのコレクションがあります。Android と iOS の両方で具体的なタスクを実行するときだけでなく、独自のスクリプトを作成するためのインスピレーションとしても役立ちます。代表的な二つの例を示します。

- Universal Android SSL Pinning Bypass with Frida - <https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/>
- ObjC method observer - <https://codeshare.frida.re/@mrmacete/objc-method-observer/>

使い方は簡単です。Frida CLI を使用するときに `--codeshare <handler>` フラグとハンドラを含めます。例えば、"ObjC method observer" を使用するには、以下のように入力します。

```bash
$ frida --codeshare mrmacete/objc-method-observer -f YOUR_BINARY
```

### 静的および動的バイナリ解析

リバースエンジニアリングはコンパイルされたプログラムのソースコードの意味を再構築するプロセスです。言い換えると、何をしているのか、どのようにしているのかを理解するために、プログラムを分割し、実行し、その一部をシミュレートし、他では言い表せないものにします。

#### 逆アセンブラと逆コンパイラの使用

逆アセンブラと逆コンパイラはアプリのバイナリコードやバイトコードを多かれ少なかれ理解できる形式に逆変換できます。ネイティブバイナリにこれらのツールを使用することで、アプリがコンパイルされたアーキテクチャに一致するアセンブラコードを取得できます。逆アセンブラはマシンコードをアセンブリコードに変換し、逆コンパイラはこのアセンブリコードを同等の高級言語コードを生成するために順に使用します。Android Java アプリは smali に逆アセンブルできます。smali は Android の Java VM である Dalvik で使用される DEX 形式のアセンブラ言語です。Smali アセンブリは逆コンパイルして同等の Java コードに戻すことも簡単です。

理論的には、アセンブリコードとマシンコード間のマッピングは一対一となるべきであるため、逆アセンブルは単純なタスクであるという印象を与える可能性があります。しかし実際には、以下のような複数の落とし穴があります。

- コードとデータ間の確実な判別。
- 可変命令サイズ。
- 間接分岐命令。
- 実行可能なコードセグメント内に明示的な CALL 命令がない関数。
- 位置独立コード (PIC) シーケンス。
- 手作りのアセンブリコード。

同様に、逆コンパイルは非常に複雑なプロセスであり、多くの決定論的および発見的アプローチに基づいています。結果として、逆コンパイルは一般的に実際には正確ではありませんが、それでも解析対象の関数をすばやく理解するのに非常に役立ちます。逆コンパイルの精度は逆コンパイルされるコードで利用可能な情報の量と逆コンパイラの洗練度に依存します。さらに、多くのコンパイルおよびポストコンパイルツールは理解や逆コンパイル自体の難しさを増すためにコンパイルされたコードをさらに複雑にします。そのようなコードを _難読化コード_ と呼びます。

長年にわたり多くのツールが逆アセンブリと逆コンパイルのプロセスを完成させ、高い忠実度で出力を作成しています。なにかしらの利用可能なツールの高度な使用手順は多くの場合それ自体の本を簡単に埋めてしまいます。開始する最善の方法はニーズと予算にあったツールを選択して十分にレビューされたユーザーガイドを取得することです。このセクションでは、これらのツールの一部を紹介し、以降の Android および iOS の「リバースエンジニアリングと改竄」の章では、特に身近にあるプラットフォームに固有のテクニック自体にフォーカスします。

##### Ghidra

Ghidra は米国の国家安全保障局 (NSA) の研究部門で開発されたツールのオープンソースのソフトウェアリバースエンジニアリング (SRE) スイートです。Ghidra は逆アセンブラ、逆コンパイラおよび高度な使用のための組込みスクリプティングエンジンで構成される汎用性の高いツールです。インストール方法については [インストールガイド](https://ghidra-sre.org/InstallationGuide.html "Ghidra Installation Guide") を参照してください。また、 [チートシート](https://ghidra-sre.org/CheatSheet.html "Cheat Sheet") で利用可能なコマンドおよびショートカットの概要も確認できます。このセクションでは、プロジェクトの作成方法、バイナリの逆アセンブリおよび逆コンパイルされたコードの閲覧方法について説明します。

使用しているプラットフォームに応じて、 `ghidraRun` (\*nix) または `ghidraRun.bat` (Windows) を使用して Ghidra を起動します。Ghidra が起動したら、プロジェクトディレクトリを指定して新しいプロジェクトを作成します。以下に示すウィンドウが表示されます。

<img src="Images/Chapters/0x04c/Ghidra_new_project.png" alt="Ghidra New Project" width="450" />

新しい **Active Project** で **File** -> **Import File** に移動して目的のファイルを選択することにより、アプリバイナリをインポートできます。

<img src="Images/Chapters/0x04c/Ghidra_import_binary.png" alt="Ghidra import binary" width="450" />

ファイルが適切に処理できる場合には、Ghidra は解析を開始する前にバイナリに関するメタ情報を表示します。

<img src="Images/Chapters/0x04c/Ghidra_elf_import.png" alt="Ghidra ELF file import" width="300" />

上記で選択したバイナリファイルの逆アセンブルコードを取得するには、 **Active Project** ウィンドウからインポートしたファイルをダブルクリックします。次のウィンドウで自動解析するには **yes** および **analyze** をクリックします。自動解析はバイナリのサイズによっては時間がかかります。コードブラウザウィンドウの右下隅で進行状況を追跡できます。自動解析を完了するとバイナリの調査を開始できます。

<img src="Images/Chapters/0x04c/Ghidra_main_window.png" alt="Ghidra Main Window" />

Ghidra でバイナリを調査するために最も重要なウィンドウは **Listing** (Disassembly) ウィンドウ、**Symbol Tree** ウィンドウおよび **Decompiler** ウィンドウです。 **Decompiler** ウィンドウは逆アセンブリ用に選択した関数の逆コンパイルバージョンを表示します。 **Display Function Graph** オプションは選択した関数の制御フローグラフを表示します。

<img src="Images/Chapters/0x04c/Ghidra_function_graph.png" alt="Ghidra Function Graph View" />

Ghidra にはほかにも多くの機能が利用可能であり、それらの多くは **Window** メニューを開いて調べることができます。たとえば、バイナリに存在する文字列を調べたい場合には、**Defined Strings** オプションを開きます。以降の章では Android および iOS プラットフォームのさまざまなバイナリを解析しながら、他の高度な機能について説明します。

<img src="Images/Chapters/0x04c/Ghidra_string_window.png" alt="Ghidra strings window" />

#### デバッグとトレース

従来の意味では、デバッグはソフトウェアライフサイクルの一部としてプログラム内の問題を特定および分離するプロセスです。デバッグに使用される同じツールは、バグを特定することが主な目的ではありませんがリバースエンジニアリングにとって価値があります。デバッガは実行時に任意の箇所でプログラムを一時停止したり、プロセスの内部状態を検査したり、レジスタやメモリの改変さえも可能です。これらの能力はプログラムの検査を容易にします。

*デバッグ* は一般的には対話的デバッグセッションを意味し、デバッガは実行中のプロセスにアタッチされます。対照的に、*トレース* は (API コールなどの) アプリの実行に関する情報の受動的なログ出力を指します。トレースは、デバッグ API、関数フック、カーネルトレース機能などのいくつかの方法で実行できます。改めて、これらの技法の多くは OS ごとの「リバースエンジニアリングと改竄」の章で説明します。

### 高度な技法

強力に難読化されたバイナリを逆難読化するなど、より複雑なタスクの場合、解析の特定の部分を自動化することなく成功することはありません。例えば、逆アセンブラでの手動解析を基にして複雑なコントロールフローグラフを理解および単純化するには何年もかかるでしょう (そして、完了する前におそらく気が狂うことでしょう) 。代わりに、カスタムメイドのツールでワークフローを増強します。幸いにも、現代の逆アセンブラにはスクリプティングと拡張 API が付属しており、一般的な逆アセンブラには多くの便利な拡張が用意されています。さらに、オープンソースの逆アセンブラエンジンやバイナリ解析フレームワークも存在します。

ハッキングの常として、何でもありのルールが適用されます。単純に最も効率的なものを使用します。すべてのバイナリは異なり、すべてのリバースエンジニアは独自のスタイルを持っています。多くの場合、目標に到達する最善の方法は (エミュレータベースのトレースやシンボリック実行など) アプローチを組み合わせることです。始めるには、優れた逆アセンブラやリバースエンジニアリングフレームワークを選択し、それらの特定の機能や格拡張 API に慣れることです。最終的には、より良くなる最善の方法は実践的な経験を積むことです。

#### 動的バイナリ計装

ネイティブバイナリに対するもう一つの便利なアプローチには動的バイナリ計装 (DBI) があります。Valgrind や PIN などの計装フレームワークは単一プロセスの細かい命令レベルのトレースをサポートします。これは動的に生成されたコードを実行時に挿入することにより実現されます。Valgrind は Android でうまくコンパイルされ、事前にビルドされたバイナリをダウンロードして利用できます。

[Valgrind README](http://valgrind.org/docs/manual/dist.readme-android.html "Valgrind README") には Android 向けのコンパイル手順が記述されています。

#### エミュレーションベースの動的解析

エミュレーションは異なるプラットフォームや別のプログラム内で実行される特定のコンピュータープラットフォームやプログラムのイミテーションです。このイミテーションを実行するソフトウェアやハードウェアは _エミュレータ_ と呼ばれます。エミュレータは実デバイスに代わるはるかに安価な代替手段を提供し、ユーザーはデバイスにダメージを与えることを心配することなく操作できます。Android には複数のエミュレータがありますが、iOS には実際に実行可能なエミュレータはほとんどありません。iOS にはシミュレータのみがあり、Xcode 内で出荷されています。

シミュレータとエミュレータの違いはしばしば混乱を引き起こし、二つの用語を同じ意味で使用することがありますが、実際には、特に iOS のユースケースでは、それらは異なるものです。エミュレータはターゲットプラットフォームのソフトウェアとハードウェア環境の両方を模倣します。一方、シミュレータはソフトウェア環境のみを模倣します。

Android 用 QEMU ベースのエミュレータはアプリケーションの実行中に RAM, CPU, バッテリーパフォーマンスなど (ハードウェアコンポーネント) を考慮しますが、iOS シミュレータでは、このハードウェアコンポーネントの動作はまったく考慮されません。iOS シミュレータは iOS カーネルの実装すらありません。結果として、アプリケーションが syscall を使用している場合にはこのシミュレータでは実行できません。

端的に言えば、エミュレータはターゲットプラットフォームに非常に近いイミテーションですが、シミュレータはその一部のみを模倣します。

エミュレータでアプリを実行することにより、その環境を監視および操作するための強力な方法が得られます。一部のリバースエンジニアリングタスク、特に低レベルの命令トレースが必要な場合、エミュレーションは最善の (または唯一の) 選択肢です。残念ながら、このタイプの解析は Android の場合にのみ実行可能です。iOS にはフリーまたはオープンソースのエミュレータが存在しないためです (iOS シミュレータはエミュレータではなく、iOS デバイス向けにコンパイルされたアプリは実行できません) 。利用可能な唯一の iOS エミュレータは商用の SaaS ソリューションである Corellium です。「Android の改竄とリバースエンジニアリング」の章で Android 向けの一般的なエミュレーションベースの解析フレームワークの概要を説明します。

<br/>
<br/>

#### リバースエンジニアリングフレームワークを使用したカスタムツール

ほとんどのプロフェッショナルな GUI ベースの逆アセンブラはスクリプト機能と拡張性を備えていますが、特定の問題を解決するにはあまり適していないことがあります。リバースエンジニアリングフレームワークは重量のある GUI に依存することなくある種のリバースエンジニアリングタスクを実行および自動化できます。特に、ほとんどのリバーシングフレームワークはオープンソースであるか、フリーで利用可能です。モバイルアーキテクチャをサポートする一般的なフレームワークには [Radare2](https://github.com/radare/radare2 "radare2") と [Angr](https://github.com/angr/angr "Angr") があります。

##### 例：シンボリック実行やコンコリック実行を使用したプログラム解析

2000年代後半には、シンボリック実行ベースのテストがセキュリティ脆弱性を特定する手段として普及しました。シンボリック「実行」とは実際にプログラムを通る可能性のあるパスを一次論理の式として表現するプロセスを指します。充足可能性モジュロ理論 (SMT) ソルバーを使用してこれらの式の充足可能性をチェックし、解決された式に対するパス上の特定の実行点に到達するために必要な変数の具体的な値などのソリューションを提供します。

簡単に言えば、シンボリック実行とはプログラムを実行せずに数学的に解析することです。解析の中で、それぞれの未知の入力は数学的変数 (シンボリック値) として表されるため、これらの変数に対して実行されるすべての操作は操作のツリー (別名、AST (抽象構文木)、コンパイラ理論より) として記録されます。これらの AST は SMT ソルバーにより解釈されるいわゆる _制約_ に変換できます。この解析の最後に、変数は値が不明な入力となる最終数学方程式が得られます。SMT ソルバーは最終状態を与えられた入力変数に可能な値を与えるためにこれらの方程式を解く特別なプログラムです。

これを説明するために、一つの入力 (`x`) を取り、二つ目の入力 (`y`) の値で乗算する関数を想像してください。最後に、_if_ 条件があります。計算された値が外部変数 (`z`) の値よりも大きいかどうかをチェックし、true の場合は "success" を返し、そうでなければ "fail" を返します。この操作の方程式は `(x * y) > z` になるでしょう。

関数が常に "success" (最終状態) を返すようにしたい場合、対応する方程式を満たす `x` と `y` (入力変数) の値を計算するように SMT ソルバーに伝えることができます。グローバル変数の場合と同様に、それらの値はこの関数の外部から変更でき、この関数が実行されるたびに異なる出力となる可能性があります。これにより正しいソリューションを決定する際の複雑さが増します。

内部的な SMT ソルバーはさまざまな方程式解法を使用して、そのような方程式の解を生成します。いくつかの技法は非常に高度であり、それらの議論は本書の範疇を超えています。

現実世界の状況では、関数は上記の例よりもはるかに複雑です。関数の複雑さが増すと従来のシンボリック実行に大きな課題が生じる可能性があります。課題のいくつかを以下に要約します。

- プログラム内のループと再帰は *無限実行ツリー* につながる可能性があります。
- 複数の条件分岐やネストされた条件は *パス爆発* につながる可能性があります。
- シンボリック実行により生成された複雑な方程式は SMT ソルバーの制限により解決できない可能性があります。
- プログラムはシンボリック実行では処理できないシステムコール、ライブラリコール、またはネットワークイベントを使用しています。

これらの課題を克服するには、通常、シンボリック実行を _動的実行_ (_具象的実行_ とも呼ばれる) などの他の技法と組み合わせて、従来のシンボリック実行に特有のパス爆発を軽減します。この具象的な (実際の) 実行とシンボリック実行の組み合わせは _コンコリック実行_ (concolic という名前は **conc**rete と symb**olic** に由来します) と呼ばれ、*動的シンボリック実行* と呼ばれることもあります。

これを視覚化するために、上記の例では、さらにリバースエンジニアリングを実行するかプログラムを動的に実行してこの情報をシンボリック実行解析に渡すことにより、外部変数の値を取得できます。この追加情報により方程式の複雑さを軽減し、より正確な解析結果を生み出すこともあります。改善された SMT ソルバーと現在のハードウェアスピードを併せることで、コンコリック実行は中規模のソフトウェアモジュール (10 KLOC 程度) のパスを探索できます。

さらに、シンボリック実行はコントロールフローグラフの簡素化など逆難読化タスクのサポートにも役立ちます。例えば、Jonathan Salwan と Romain Thomas は [動的シンボリック実行を使用して VM ベースのソフトウェア保護をリバースエンジニアリングする方法を示しました](https://triton.quarkslab.com/files/csaw2016-sos-rthomas-jsalwan.pdf "Jonathan Salwan and Romain Thomas: How Triton can help to reverse virtual machine based software protections") [#salwan] (つまり、実際の実行トレース、シミュレーション、シンボリック実行を組み合わせて使用します) 。

Android のセクションでは、シンボリック実行を使用して Android アプリケーションの簡単なライセンスチェックをクラックするためのウォークスルーを説明します。

### 参考情報

- [#vadla] Ole André Vadla Ravnås, Anatomy of a code tracer - <https://medium.com/@oleavr/anatomy-of-a-code-tracer-b081aadb0df8>
- [#salwan] Jonathan Salwan and Romain Thomas, How Triton can help to reverse virtual machine based software protections - <https://triton.quarkslab.com/files/csaw2016-sos-rthomas-jsalwan.pdf>

#### ツール

- Angr - <https://github.com/angr/angr>
- Cycript - <http://www.cycript.org/>
- Frida - <https://www.frida.re/>
- Frida CLI - <https://www.frida.re/docs/frida-cli/>
- frida-ls-devices - <https://www.frida.re/docs/frida-ls-devices/>
- frida-ps - <https://www.frida.re/docs/frida-ps/>
- frida-trace - <https://www.frida.re/docs/frida-trace/>
- Fridump - <https://github.com/Nightbringer21/fridump>
- Objection - <https://github.com/sensepost/objection>
- Passionfruit - <https://github.com/chaitin/passionfruit>
- Ghidra - <https://github.com/NationalSecurityAgency/ghidra>
- Radare2 - <https://github.com/radare/radare2>
- r2frida - <https://github.com/nowsecure/r2frida>
- Substrate - <http://www.cydiasubstrate.com/>
- Xposed - <https://www.xda-developers.com/xposed-framework-hub/>
