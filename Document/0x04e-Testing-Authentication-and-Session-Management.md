# モバイルアプリの認証アーキテクチャ

認証と認可の問題はよくあるセキュリティ脆弱性です。実際、それらは [OWASP Top 10](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project "OWASP Top Ten Project") で一貫して二位という高いランクをつけています。

ほとんどのモバイルアプリは何かしらのユーザー認証を実装しています。認証および状態管理ロジックの一部はバックエンドサービスで実行されますが、認証はほとんどのモバイルアプリアーキテクチャに不可欠な要素であるため、一般的な実装を理解することが重要です。

基本的な概念は iOS と Android で同一なので、この一般的なガイドではよくある認証と認可アーキテクチャと落とし穴について説明します。ローカル認証や生体認証などの OS 固有の認証問題についてはそれぞれ OS 固有の章で説明します。

## 認証のテストに関する一般的なガイドライン

認証にはすべてに適応できる万能なアプローチはありません。アプリの認証アーキテクチャをレビューするときには、まず認証方法が特定のコンテキストで適切かどうかを考慮すべきです。認証は以下の一つ以上に基づいて行うことができます。

- ユーザーが知っていること (パスワード, PIN, パターンなど)
- ユーザーが持っているもの (SIM カード, ワンタイムパスワードジェネレータ, ハードウェアトークン)
- ユーザーの生体属性 (指紋, 網膜, 音声)

モバイルアプリにより実装される認証手続きの数は、機能やアクセスされるリソースの機密性に依存します。認証機能をレビューする際には業界のベストプラクティスを参照します。ユーザー名／パスワード認証 (適正なパスワードポリシーと組み合わせた) はユーザーログインがありそれほど機密性が高くはないアプリには一般的に十分であると考えられています。この形式の認証はほとんどのソーシャルメディアアプリで使用されています。

機密性の高いアプリでは、通常、二要素認証を加えることが適切です。これには非常に機密性の高い情報 (クレジットカード番号など) へのアクセスを提供したりユーザーが送金できるアプリが含まれます。一部の業界では、これらのアプリは特定の標準にも準拠する必要があります。例えば、金融アプリは Payment Card Industry Data Security Standard (PCI DSS) 、グラム・リーチ・ブライリー法、サーベンス・オクスリー法 (SOX) に確実に準拠する必要があります。米国の医療部門のコンプライアンスに関する考慮事項には、医療保険の相互運用性と説明責任に関する法令 (HIPAA) および Patient Safety Rule があります。

[OWASP Mobile AppSec Verification Standard](https://github.com/OWASP/owasp-masvs/blob/master/Document/0x09-V4-Authentication_and_Session_Management_Requirements.md "OWASP MASVS: Authentication") をガイドラインとして使用することもできます。クリティカルではないアプリ ("Level 1") の場合、MASVS は以下の認証要件を示します。

- アプリがユーザーにリモートサービスへのアクセスを提供する場合、ユーザー名/パスワード認証など何らかの形態の認証がリモートエンドポイントで実行されている。
- パスワードポリシーが存在し、リモートエンドポイントで実施されている。
- 誤った認証資格情報が過剰な回数送信された場合、リモートエンドポイントはエクスポネンシャルバックオフを実装するか、ユーザーアカウントを一時的にロックしている。

機密性の高いアプリ ("Level 2") の場合、MASVS は以下を追加します。

- リモートエンドポイントに二要素認証が存在し、リモートエンドポイントで二要素認証要件が一貫して適用されている。
- 機密データまたはトランザクションを処理するアクションを有効にするにはステップアップ認証を必要としている。
- アプリはユーザーがログインしたときにそのアカウントでの最近のアクティビティをユーザーに通知している。

上記の要件をテストする方法の詳細について次のセクションで説明しています。

<br/>
<br/>

### ステートフル認証とステートレス認証

通常、モバイルアプリはトランスポート層として HTTP を使用します。HTTP プロトコル自体はステートレスであるため、ユーザーの後続の HTTP リクエストをそのユーザーに関連付ける方法が必要です。そうでない場合、ユーザーのログイン資格情報はリクエストごとに送信する必要があります。また、サーバーとクライアントの両方がユーザーデータ (ユーザーの権限や役割など) を追跡し続ける必要があります。これには二つの異なる方法で行うことが可能です。

- *ステートフル* 認証では、ユーザーがログインする際に一意のセッション ID が生成されます。以降のリクエストでは、このセッション ID はサーバーに保存されているユーザー詳細への参照として機能します。セッション ID は *不透明* であり、ユーザーデータは含まれていません。

- *ステートレス* 認証では、すべてのユーザー識別情報がクライアント側トークンに保存されます。トークンは任意のサーバーやマイクロサービスに渡すことができ、サーバーでセッション状態を維持する必要がなくなります。スレートレス認証は多くの場合ユーザーのログイン時にトークンを生成、署名、およびオプションで暗号化する認可サーバーに組み込まれています。

ウェブアプリケーションは一般的にクライアント側 Cookie に保存されているランダムセッション ID でステートフル認証を使用します。モバイルアプリはしばしば同様の方法でステートフルセッションを使用しますが、ステートレストークンベースのアプローチがさまざまな理由で一般的になりつつあります。

- サーバーにセッション状態を保存する必要がなくなるため、スケーラビリティとパフォーマンスが向上します。
- トークンにより開発者はアプリから認証を分離できます。トークンは認証サーバーで生成でき、認証スキームはシームレスに変更できます。

モバイルセキュリティテスト担当者として、両方のタイプの認証に精通しているべきです。

### 補助認証

認証スキームは [パッシブコンテキスト認証](https://pdfs.semanticscholar.org/13aa/7bf53070ac8e209a84f6389bab58a1e2c888.pdf "Best Practices for Multi-factor Authentication") により補完されることがよくあります。
これは以下を取り込むことができます。

- 位置情報
- IP アドレス
- 時刻
- 使用されているデバイス

理想的には、このようなシステムではユーザーのコンテキストを以前に記録されたデータと比較し、アカウントの悪用や不正の可能性を示す異常を識別します。このプロセスはユーザーには分かりきったことですが、攻撃者にとって強力な抑止力となり得ます。

## 適切な認証が設定されていることを検証する (MSTG-ARCH-2 and MSTG-AUTH-1)

認証と認可をテストする際には以下の手順を実行します。

- アプリが使用する追加の認証要素を特定します。
- 重要な機能を提供するすべてのエンドポイントを突き止めます。
- 追加の要素がすべてのサーバー側エンドポイントで厳密に実施されていることを検証します。

認証バイパス脆弱性はサーバーで認証状態が一貫して実施されておらず、クライアントが状態を改竄できる場合に存在します。バックエンドサービスはモバイルクライアントからのリクエストを処理している間、一貫して認可チェックを実施する必要があります。つまり、リソースがリクエストされるごとにユーザーがログインし認可されていることを検証します。

[OWASP Web Testing Guide](https://www.owasp.org/index.php/Testing_for_Bypassing_Authentication_Schema_%28OTG-AUTHN-004%29 "Testing for Bypassing Authentication Schema (OTG-AUTHN-004)") の以下の例を考えてみます。この例では、ウェブリソースは URL を介してアクセスされており、認証状態は GET パラメータを介して渡されます。

```html
http://www.site.com/page.asp?authenticated=no
```

クライアントはリクエストとともに送られる GET パラメータを任意に変更できます。クライアントが `authenticated` パラメータの値を単に "yes" に変更して、事実上認証をバイパスすることを妨げるものは何もありません。

これは実際に見つかることはないであろう過度に単純化した例ですが、プログラマーは認証状態を維持するために Cookie などの「隠された」クライアント側パラメータに依存することがあります。彼らはこれらのパラメータが改竄できないと想定しています。例えば、次の [Nortel Contact Center Manager の古典的な脆弱性](http://seclists.org/bugtraq/2009/May/251 "SEC Consult SA-20090525-0 :: Nortel Contact Center Manager Server Authentication Bypass Vulnerability") を考えてみます。Nortel のアプライアンスの管理ウェブアプリケーションは "isAdmin" Cookie に依存して、ログインユーザーに管理者特権を付与する必要があるかどうかを判断していました。その結果、以下のように Cookie の値を設定するだけで管理者アクセスを取得できました。

```html
isAdmin=True
```

かつてセキュリティ専門家はセッションベースの認証を使用し、サーバー上でのみセッションデータを維持することを推奨していました。これによりクライアント側でセッション状態が改竄されることを防ぎます。ただし、セッションベース認証の代わりにステートレス認証を使用することの重要な点はサーバーでセッション状態を *持たない* ことです。代わりに、状態はクライアント側トークンに格納され、すべてのリクエストとともに送信されます。この場合には、 `isAdmin` のようなクライアント側パラメータを見ることは完全に正常です。

改竄を防ぐためには暗号化署名をクライアント側トークンに追加します。もちろん、物事は悪くなる可能性があり、ステートレス認証の一般的な実装は攻撃に対して脆弱です。例えば、一部の JSON Web Token (JWT) 実装の署名検証は [署名タイプを "None" に設定すること](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/ "Critical vulnerabilities in JSON Web Token libraries") により無効化できます。この攻撃については「JSON Web Token のテスト」の章で詳しく説明します。

## パスワードに対するベストプラクティスのテスト (MSTG-AUTH-5 and MSTG-AUTH-6)

パスワードが認証に使用される場合、パスワードの強度は重要事項です。パスワードポリシーはエンドユーザーが遵守すべき要件を定義します。パスワードポリシーは一般的にパスワードの長さ、パスワードの複雑さ、およびパスワードのトポロジーを指定します。「強力な」パスワードポリシーにより手動または自動のパスワードクラッキングが困難あるいは不可能になります。以下のセクションではパスワードのベストプラクティスに関するさまざまな分野について説明します。詳細については [OWASP Authentication Cheat Sheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md#implement-proper-password-strength-controls "Implement Proper Password Strength Controls") を参照してください。

### 静的解析

パスワードポリシーの存在を確認し、実装されたパスワードの複雑さの要件を、長さと無制限の文字セットにフォーカスした [OWASP Authentication Cheat Sheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md#implement-proper-password-strength-controls "Implement Proper Password Strength Controls") に従って検証します。ソースコード内のすべてのパスワード関連機能を特定し、それぞれで検証チェックが行われていることを確認します。パスワード検証機能をレビューし、パスワードポリシーに違反するパスワードを拒否することを確認します。

#### zxcvbn

[zxcvbn](https://github.com/dropbox/zxcvbn "zxcvbn") はパスワード強度を推定するために使用できる一般的なライブラリで、パスワードクラッカーから発想しました。JavaScript で利用可能ですが、サーバー側の他の多くのプログラミング言語でも使用できます。インストールには様々な方法があります。好みの方法については GitHub リポジトリを確認してください。インストールした後、zxcvbn を使用してパスワードをクラックするための複雑さと推定量を計算できます。

zxcvbn JavaScript ライブラリを HTML ページに追加した後、ブラウザコンソールで `zxcvbn` を実行して、スコアを含むパスワードをクラックする可能性に関する詳細情報を取得できます。

![OWASP MSTG](Images/Chapters/0x04e/zxcvbn.png) \

スコアは以下のように定義され、例えばパスワード強度バーに使用できます。

```html
0 # 推測可能性 大 (too guessable): 危険なパスワード。 (推量 < 10^3)

1 # 推測可能性 中 (very guessable): 抑制された (throttled) オンライン攻撃からの保護。 (推量 < 10^6)

2 # 推測可能性 小 (somewhat guessable): 抑制なし (unthrottled) オンライン攻撃からの保護。 (推量 < 10^8)

3 # 推測可能性 安全 (safely unguessable): オフライン低速ハッシュシナリオからの適度な保護。 (推量 < 10^10)

4 # 推測可能性 ほぼ不可 (very unguessable): オフライン低速ハッシュシナリオからの強力な保護。 (推量 >= 10^10)
```

zxcvbn はアプリ開発者が Java (またはその他の) 実装を使用してユーザーが強力なパスワードを作成できるように実装することも可能であることに留意します。

### Have I Been Pwned: PwnedPasswords

単一要素認証スキーム (たとえばパスワードのみ) に対する辞書攻撃の成功の可能性を減らすために、データ侵害でパスワードが危殆化されているかどうかを検証できます。これは Troy Hunt による Pwned Passwords API (api.pwnedpasswords.com で利用可能) に基づくサービスを使用して実行できます。例えば、"[Have I been pwned?](https://haveibeenpwned.com "\';--have i been pwned?")" コンパニオンウェブサイトがあります。
可能性のあるパスワード候補の SHA-1 ハッシュに基づいて、API は指定されたパスワードのハッシュがサービスにより収集されたさまざまな侵害で見つかった回数を返します。このワークフローは以下のステップで実行します。

- ユーザー入力を UTF-8 にエンコードします (例: パスワード `test`) 。
- ステップ 1 の結果の SHA-1 ハッシュを取得します (例: `test` のハッシュは `A94A8FE5CC...` です) 。
- 最初の 5 文字 (ハッシュプレフィックス) をコピーし、次の API を使用して範囲検索に使用します: `http GET https://api.pwnedpasswords.com/range/A94A8`
- 結果を反復処理し、ハッシュの残りを探します (例 `FE5CC...` は返されたリストの一部であるか) 。それが返されたリストの一部ではない場合、指定されたハッシュのパスワードは見つかりませんでした。そうでない場合、`FE5CC...` の場合では、侵害で検出された回数を示すカウンターが返されます (例: `FE5CC...:76479`) 。

Pwned Passwords API の詳細なドキュメントは [オンライン](https://haveibeenpwned.com/API/v3 "Api Docs V3") にあります。

この API はユーザーがパスワードを登録および入力して推奨パスワードかどうかをチェックする必要がある場合に、アプリ開発者が使用することが最適であることに注意します。

#### ログインスロットリング

スロットリング手続きについてはソースコードをチェックします。特定のユーザー名で短時間に試行されたログインのカウンターや、最大試行回数に達した後にログイン試行を防止する方法です。認可されたログイン試行後、エラーカウンターはリセットされている必要があります。

アンチブルートフォースコントロールを実装する場合には以下のベストプラクティスを遵守します。

- 数回ログインに失敗した後、対象のアカウントを (一時的または永続的に) ロックして、さらなるログイン試行を拒否する必要があります。
- 五分間のアカウントロックは一時的なアカウントロックに一般的に使用されます。
- コントロールはサーバー上に実装する必要があります。クライアント側コントロールは簡単にバイパスされるためです。
- 不正なログイン試行は特定のセッションではなく対象のアカウントに関して集計する必要があります。

さらなるブルートフォース緩和技法については OWASP ページ [ブルートフォース攻撃のブロック](https://www.owasp.org/index.php/Blocking_Brute_Force_Attacks "OWASP - Blocking Brute Force Attacks") で説明されています。

### 動的テスト (MSTG-AUTH-6)

自動パスワード推測攻撃は多くのツールを使用して実行できます。HTTP(S) サービスでは、傍受プロキシを使用することが実行可能な選択肢です。例えば、[Burp Suite Intruder](https://portswigger.net/burp/documentation/desktop/tools/intruder/using "Using Burp Suite Intruder") を使用して、ワードリストベースの攻撃とブルートフォース攻撃の両方を実行できます。

> Burp Suite Community Edition にはプロジェクトを保存できないこととは別に重要な制限があることに注意してください。例えば、スロットリングメカニズムは Burp Intruder での攻撃を劇的に遅くするいくつかのリクエストの後にアクティブになります。また、このバージョンではビルトインのパスワードリストは利用できません。リアルなブルートフォース攻撃を実行したい場合には [Burp Suite](0x08-Testing-Tools.md#burp-suite) Professional か [OWASP ZAP](0x08-Testing-Tools.md#owasp-zap) のいずれかを使用します。

Burp Intruder でのワードリストベースのブルートフォース攻撃には以下の手順を実行します。

- Burp Suite Professional を起動します。
- 新しいプロジェクトを作成します (または既存のプロジェクトを開きます) 。
- Burp を HTTP/HTTPS プロキシとして使用するようにモバイルデバイスをセットアップします。モバイルアプリにログインし、バックエンドサービスに送信される認証リクエストを傍受します。
- **Proxy/HTTP History** タブでこのリクエストを右クリックし、コンテキストメニューの **Send to Intruder** を選択します。
- **Intruder** タブを選択します。[Burp Intruder](https://portswigger.net/burp/documentation/desktop/tools/intruder/using "Using Burp Intruder") の使用方法の詳細については Portswigger の公式ドキュメントを参照します。
- **Target**, **Positions**, **Options** タブのすべてのパラメータが適切に設定されていることを確認し、**Payload** タブを選択します。
- 試したいパスワードのリストをロードまたは貼り付けます。パスワードリストを提供するリソースには [FuzzDB](https://github.com/fuzzdb-project/fuzzdb/ "FuzzDB") 、Burp Intruder のビルトインリスト、Kali Linux の `/usr/share/wordlists` で利用可能なファイルなどがあります。

すべてを設定しワードリストを選択したら、攻撃を開始する準備が整いました。

![OWASP MSTG](Images/Chapters/0x04e/BurpIntruderInputList.png) \

- **Start attack** ボタンをクリックして認証を攻撃します。

新しいウィンドウが開きます。サイトリクエストは順番に送信され、各リクエストはリストのパスワードに対応します。レスポンスに関する情報 (長さ、ステータスコードなど) が各リクエストに対して提供されるため、成功した試行と失敗した試行を区別できます。

![OWASP MSTG](Images/Chapters/0x04e/BurpIntruderSuccessfulAttack.png) \

この例では、パスワード 12345 を明らかにする、異なる長さと HTTP ステータスコードにより成功した試行を識別できます。

独自のテストアカウントがブルートフォースを受けやすいかどうかをテストするには、テストアカウントの正しいパスワードをパスワードリストの最後に追加します。リストには 25 を超えるパスワードを含めるべきではありません。間違ったパスワードでの一定量のリクエストの後、アカウントを一時的または永続的にロックしたり CAPTCHA を解決したりせずに攻撃を完了できる場合、そのアカウントはブルートフォース攻撃から保護されていないことを意味します。

> 情報: これらの種類のテストはペネトレーションテストの最後にのみ実行します。テストの初日にアカウントをロックアウトしたくありませんし、アンロックされるまで待つ必要があるかもしれません。一部のプロジェクトではアカウントのアンロックは思った以上に難しいことがあります。

## ステートフルセッション管理のテスト (MSTG-AUTH-2)

ステートフル (または「セッションベース」) 認証はクライアントとサーバーの両方の認証レコードにより特徴付けられます。認証フローは以下の通りです。

1. アプリはユーザーの資格情報を含むリクエストをバックエンドサーバーに送信します。
2. サーバーは資格情報を検証します。資格情報が有効である場合、サーバーはランダムセッション ID とともに新しいセッションを作成します。
3. サーバーはそのセッション ID を含むレスポンスをクライアントに送信します。
4. クライアントは後続のすべてのリクエストとともにそのセッション ID を送信します。サーバーはセッション ID を妥当性確認し、関連するセッションレコードを取得します。
5. ユーザーがログアウトした後、サーバー側セッションレコードは破壊され、クライアントはセッション ID を破棄します。

セッションが不適切に管理されると、正規ユーザーのセッションを危殆化する可能性のあるさまざまな攻撃に対して脆弱になり、攻撃者がそのユーザーになりすますことができます。これによりデータの損失、機密性の危殆化、および不正行為が発生する可能性があります。

### セッション管理のベストプラクティス

機密情報や機能を提供するサーバー側エンドポイントをすべて見つけ、認可の一貫した実施を検証します。バックエンドサービスはユーザーのセッション ID またはトークンを検証し、ユーザーがリソースにアクセスするために十分な権限を持っていることを確認する必要があります。セッション ID またはトークンが欠落しているか無効である場合には、そのリクエストは拒否する必要があります。

以下を確認します。

- セッション ID はサーバー側でランダムに生成されています。
- その ID は簡単には推測できません (適切な長さとエントロピーを使用しています) 。
- セッション ID は常にセキュアな接続 (HTTPS など) の上で交換されています。
- モバイルアプリはセッション ID を永続的なストレージに保存していません。
- サーバーはユーザーが特権アプリケーション要素にアクセスしようとするたびにそのセッションを検証します (セッション ID は有効であり、適切な認可レベルに対応している必要があります) 。
- タイムアウトまたはユーザーがログアウトした後、セッションはサーバー側で終了し、モバイルアプリ内のセッション情報は削除されています。

認証はゼロから実装すべきではなく、実績のあるフレームワークの上に構築すべきです。多くの著名なフレームワークは既製の認証およびセッション管理機能を提供します。アプリが認証にフレームワーク API を使用している場合、ベストプラクティスについてはそのフレームワークのセキュリティドキュメントをチェックします。一般的なフレームワークについてのセキュリティガイドは以下のリンクから利用可能です。

- [Spring (Java)](https://projects.spring.io/spring-security "Spring (Java)")
- [Struts (Java)](https://struts.apache.org/security/ "Struts (Java)")
- [Laravel (PHP)](https://laravel.com/docs/5.4/authentication "Laravel (PHP)")
- [Ruby on Rails](https://guides.rubyonrails.org/security.html "Ruby on Rails")

サーバー側認証のテストについての優れたリソースには OWASP Web Testing Guide があり、特に [Testing Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README) および [Testing Session Management](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README) の章をご覧ください。

## セッションタイムアウトのテスト (MSTG-AUTH-7)

セッション識別子およびトークンの存続期間を最小化すると、アカウントハイジャックを成功する可能性が低くなります。

### 静的解析

最も著名なフレームワークでは、構成オプションを介してセッションタイムアウトを設定できます。このパラメータはそのフレームワークのドキュメントで指定されているベストプラクティスに従って設定すべきです。推奨されるタイムアウトは 10 分から二時間の間で、アプリの機密さによります。セッションタイムアウト設定の例についてはフレームワークのドキュメントを参照します。

- [Spring (Java)](https://docs.spring.io/spring-session/docs/current/reference/html5/ "Spring (Java)")
- [Ruby on Rails](https://guides.rubyonrails.org/security.html#session-expiry "Ruby on Rails")
- [PHP](https://php.net/manual/en/session.configuration.php#ini.session.gc-maxlifetime "PHP")
- [ASP.Net](https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.httpsessionstate.timeout "ASP.NET")

### 動的解析

セッションタイムアウトが実装されているかどうかを検証するには、傍受プロキシを通してリクエストをプロキシし、以下の手順を実行します。

1. アプリケーションにログインします。
2. 認証が必要となるリソースにアクセスします。通常はアカウントに属する個人情報についてのリクエストです。
3. 5 の倍数分 (5, 10, 15, ...) 遅延が経過した後、そのデータにアクセスを試みます。
4. リソースが利用できなくなっていれば、セッションタイムアウトがわかります。

セッションタイムアウトを特定した後、それがアプリケーションに適切な長さであるかどうかを検証します。タイムアウトが長すぎる場合、またはタイムアウトが存在しない場合、このテストケースは失敗です。

> Burp Proxy を使用する場合、[Session Timeout Test extension](https://portswigger.net/bappstore/c4bfd29882974712a1d69c6d8f05874e "Session Timeout Test extension") を使用してこのテストを自動化できます。

## ユーザーログアウトのテスト (MSTG-AUTH-4)

このテストケースの目的はログアウト機能を検証し、クライアントとサーバーの両方でセッションを効果的に終了するかどうか、およびステートレストークンを無効にするかどうかを判断することです。

サーバー側セッションの破棄に失敗することは、最も一般的なログアウト機能実装エラーのひとつです。このエラーはユーザーがアプリケーションからログアウトした後でもセッションまたはトークンを存続させます。有効な認証情報を取得した攻撃者は引き続きそれを使用してユーザーのアカウントをハイジャックできます。

多くのモバイルアプリはユーザーを自動的にログアウトしません。顧客には不便であるため、ステートレス認証を実装する際に下された判断などさまざまな理由があります。アプリケーションは依然としてログアウト機能を持つべきであり、ベストプラクティスに従って実装し、ローカルに保存されているすべてのトークンおよびセッション識別子を破棄すべきです。セッション情報がサーバー上に保存されている場合、そのサーバーにログアウトリクエストを送信することによりそのセッション情報も破棄すべきです。高リスクのアプリケーションの場合、トークンを無効にすべきです。トークンやセッション識別子を削除しなければ、そのトークンが漏洩した場合にアプリケーションへの不正アクセスを生じる可能性があります。
他の機密情報も削除すべきであることに注意します。適切に消去されていない情報は後で、例えばデバイスバックアップの中で、漏洩する可能性があるためです。

### 静的解析

サーバーコードが利用可能な場合、ログアウト機能がセッションを正しく終了していることを確認します。この検証はその技法に依存します。適切なサーバー側ログアウトに対するセッション終了のさまざまな例を以下に示します。

- [Spring (Java)](https://docs.spring.io/autorepo/docs/spring-security/4.1.x/apidocs/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html "Spring (Java)")
- [Ruby on Rails](https://guides.rubyonrails.org/security.html "Ruby on Rails")
- [PHP](https://php.net/manual/en/function.session-destroy.php "PHP")

ステートレス認証でアクセストークンおよびリフレッシュトークンを使用する場合、それらをモバイルデバイスから削除すべきです。[サーバー上でリフレッシュトークンを無効にすべきです](https://auth0.com/blog/denylist-json-web-token-api-keys/ "Invalidating JSON Web Token API Keys") 。

### 動的解析

動的アプリケーション解析に傍受プロキシを使用し、以下の手順を実行して、ログアウトが適切に実装されているかどうかをチェックします。

1. アプリケーションにログインします。
2. 認証が必要となるリソースにアクセスします。通常はアカウントに属する個人情報についてのリクエストです。
3. アプリケーションからログアウトします。
4. ステップ 2 からのリクエストを再送信して、データへのアクセスを再試行します。

ログアウトがサーバー上で正しく実装されている場合、エラーメッセージまたはログインページへのリダイレクトがクライアントに送り返されます。一方で、ステップ 2 で得たものと同じレスポンスを受信した場合、トークンやセッション ID は依然として有効であり、サーバー上で正しく終了していません。
OWASP Web Testing Guide ([OTG-SESS-006](https://www.owasp.org/index.php/Testing_for_logout_functionality_%28OTG-SESS-006%29 "OTG-SESS-006")) には詳細な説明と多くのテストケースがあります。

## 二要素認証およびステップアップ認証のテスト (MSTG-AUTH-9 および MSTG-AUTH-10)

二要素認証 (2FA) はユーザーが機密性の高い機能やデータにアクセスできるようにするアプリの標準です。一般的な実装では一番目の要素にパスワードを使用し、二番目の要素に以下のいずれかを使用します。

- SMS によるワンタイムパスワード (SMS-OTP)
- 電話呼び出しによるワンタイムパスワード
- ハードウェアまたはソフトウェアトークン
- PKI およびローカル認証と組み合わせたプッシュ通知

二番目の要素として使用するオプションが何であれ、常にサーバー側で適用および検証する必要があり、クライアント側で行ってはいけません。そうしないと二番目の要素はそのアプリ内で容易にバイパスできます。

セカンダリ認証はユーザーのセッションのログイン時またはそれ以降で実行できます。例えば、ユーザー名と PIN で銀行アプリにログインした後、そのユーザーは機密性の低いタスクを実行することを認可されます。ユーザーが銀行振り込みを実行しようとした場合、二番目の要素 (「ステップアップ認証」) が提示される必要があります。

### SMS-OTP の危険性

SMS により送信されるワンタイムパスワード (OTP) は二要素認証の一般的な二番目の要素ですが、この方法には欠点があります。2016年に、NIST は「SMS メッセージには傍受またはリダイレクトされるリスクがあるため、新しいシステムの実装者は代替認証子を慎重に検討すべき (SHOULD) である。」と提案しました。以下に SMS-OTP への攻撃を成功させないための関連する脅威と提案のリストを示します。

脅威:

- ワイヤレス傍受: 攻撃者は通信ネットワーク内のフェムトセルやその他の既知の脆弱性を悪用することにより SMS メッセージを傍受できます。
- トロイの木馬: テキストメッセージにアクセスできる悪意のあるアプリケーションをインストールすると、OTP を別の番号またはバックエンドに転送される可能性があります。
- SIM SWAP 攻撃: この攻撃では、攻撃者はその電話会社に電話するか、電話会社に働きかけ、被害者の番号を攻撃者が所有する SIM カードに移動させます。成功すると、攻撃者は被害者の電話番号に送信された SMS メッセージを見ることができます。これには二要素認証で使用されるメッセージが含まれます。
- 検証コード転送攻撃: このソーシャルエンジニアリング攻撃は OTP を提供する会社に対するユーザーの信頼に依存しています。この攻撃では、ユーザーはコードを受け取り、以降は情報を受信したのと同じ手段を使用してコードを中継するよう求められます。
- ボイスメール: 一部の二要素認証スキームでは SMS が選ばれないまたは利用できない場合に OTP を電話呼び出しにより送信できます。これらの呼び出しの多くは、応答されない場合、ボイスメールに情報を送信します。攻撃者がボイスメールにアクセスできた場合、OTP を使用してユーザーのアカウントにアクセスすることも可能です。

OTP に SMS を使用する場合に悪用の可能性を減らすためのいくつかの提案を以下に示します:

- **メッセージング**: OTP を SMS により送信する場合、ユーザーに次のことを知らせるメッセージを含めるようにします。 1) コードを要求していない場合の対処方法 2) 会社はパスワードまたはコードを中継するような要求を電話したりテキストを送ったりすることはないこと
- **専用チャンネル**: OS プッシュ通信機能 (iOS の APN および Android の FCM) を使用する場合、OTP を登録済みアプリケーションにセキュアに送信できます。この情報は、SMS と比較して、他のアプリケーションからアクセス可能ではありません。OTP の代わりにプッシュ通信はポップアップをトリガーして要求されたアクセスを承認できます。
- **エントロピー**: 高いエントロピーを持つ認証子を使用して OTP をクラックまたは推測しにくくし、少なくとも 6 桁を使用します。ユーザーがアプリにコピーするために覚えておく必要がある場合には数字が小さなグループに分かれていることを確認します。
- **ボイスメールの回避**: ユーザーが電話呼び出しを受けることを選択した場合、OTP 情報をボイスメールとして残さないようにします。

### プッシュ通信と PKI を使用したトランザクション署名

二番目の要素を実装するもう一つの代替であり強力なメカニズムはトランザクション署名です。

トランザクション署名は重要なトランザクションに対するユーザーの承認の認証が必要です。非対称暗号化はトランザクション署名を実装する最良の方法です。ユーザーがサインアップすると、アプリは公開鍵と秘密鍵のペアを生成し、バックエンドに公開鍵を登録します。秘密鍵は KeyStore (Android) または KeyChain (iOS) にセキュアに保存されます。トランザクションを認可するために、バックエンドはモバイルアプリにトランザクションデータを含むプッシュ通知を送信します。それからユーザーはそのトランザクションを確認または拒否するように求められます。確認後、ユーザーは (PIN または指紋を入力して) キーチェーンをアンロックするよう促され、データはユーザーの秘密鍵で署名されます。その後、署名されたトランザクションはサーバーに送信され、ユーザーの公開鍵で署名が検証されます。

### 静的解析

サードパーティーライブラリから外部アプリの使用や開発者による自己実装チェックまで、さまざまな二要素認証メカニズムを利用できます。

まずアプリを使用して、ワークフロー内で 2FA が必要な場所を特定します (通常はログイン時または重要なトランザクションの実行時です) 。また、開発者やアーキテクトにインタビューして 2FA 実装についてさらに理解します。サードパーティライブラリや外部アプリが使用されている場合には、その実装がセキュリティベストプラクティスに従って行われているかどうかを検証します。

### 動的テスト

傍受プロキシを使用してリモートエンドポイントに送信されるリクエストをキャプチャしながら、アプリを広範囲に (すべての UI フローを通して) 使用します。次に、まだ 2FA またはステップアップ認証により昇格されていないトークンやセッション ID を使用しながら、2FA を必要とするエンドポイント (例えば、金融取引の実行) にリクエストを再送します。依然としてエンドポイントが 2FA またはステップアップ認証の後にのみ利用可能であるはずのリクエストされたデータを送り返している場合、認証チェックはそのエンドポイントで適切に実装されていません。

OTP 認証が使用されている場合、ほとんどの OTP は短い数値であることを考慮します。この段階で N 回試行に失敗した後にアカウントがロックされていない場合、攻撃者は OTP の有効期間内の範囲内の値をブルートフォースすることにより二番目の要素をバイパスできます。72 時間以内に 30 秒のタイムステップで 6 桁の値への一致を見つけられる可能性は 90% 以上です。

これをテストするには、正しい OTP を提供する前にキャプチャされた要求をランダムな OTP 値とともに 10 ～ 15 回エンドポイントに送信する必要があります。それでも OTP が受け入れられる場合、2FA 実装はブルートフォース攻撃を受けやすく OTP は推測される可能性があります。

> OTP は特定の時間 (通常 30 秒) のみ有効とすべきであり、OTP に誤って数回 (通常 3 回) キー入力した後には提供された OTP は無効にすべきであり、ユーザーはランディングページにリダイレクトされるかログアウトされるべきです。

セッション管理のテストについての詳細情報は [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/01-Testing_for_Session_Management_Schema "OWASP Testing Guide V4 (Testing for Session Management)") を参照ください。

## ステートレス (トークンベース) 認証のテスト (MSTG-AUTH-3)

トークンベース認証は HTTP リクエストごとに (サーバーにより検証済みの) 署名トークンを送信することにより実装されています。最も一般的に使用されるトークン形式は JSON Web Token であり、[RFC7519](https://tools.ietf.org/html/rfc7519 "RFC7519") で定義されています。JWT は完全なセッション状態を JSON オブジェクトとしてエンコードできます。したがって、サーバーはセッションデータや認証情報を保存する必要はありません。

JWT トークンはドットで区切られた三つの Base64Url エンコードされたパーツで構成されています。トークン構造は以下のとおりです。

```default
base64UrlEncode(header).base64UrlEncode(payload).base64UrlEncode(signature)
```

以下の例は [Base64Url-encoded JSON Web Token](https://jwt.io/#debugger "JWT Example on jwt.io") を示しています。

```default
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikpva
G4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

*header* は一般的に二つのパーツで構成されています。トークンタイプ、これは JWT です、および署名の計算に使用されるハッシュアルゴリズムです。上記の例では、header は以下のようにデコードされます。

```json
{"alg":"HS256","typ":"JWT"}
```

トークンの二番目のパーツは *payload* で、いわゆる要求 (claim) が含まれています。要求はエンティティ (通常はユーザー) および追加のメタデータに関するステートメントです。以下に例を示します。

```json
{"sub":"1234567890","name":"John Doe","admin":true}
```

signature は JWT header で指定されたアルゴリズムをエンコードされた header 、エンコードされた payload 、および secret 値に適用することにより作成されます。例えば、HMAC SHA256 アルゴリズムを使用する場合、signature は以下の方法で作成されます。

```java
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

secret は認証サーバーとバックエンドサービスとの間で共有されていることに注意します。クライアントはそれを知りません。これはトークンが正規の認証サービスから取得されたことを証明しています。またクライアントがトークンに含まれる claim を改竄することも防止します。

### 静的解析

サーバーおよびクライアントが使用する JWT ライブラリを特定します。使用している JWT ライブラリに既知の脆弱性があるかどうかを調べます。

実装が JWT [ベストプラクティス](https://stormpath.com/blog/jwt-the-right-way "JWT the right way") に準拠していることを検証します。

- トークンを含むすべての着信リクエストについて HMAC がチェックされていることを検証します。
- 秘密署名鍵 (private signing key) または HMAC 秘密鍵 (HMAC secret key) の場所を検証します。鍵はサーバー上に残すべきであり、クライアントと共有すべきではありません。発行者および検証者のみが利用できるようにすべきです。
- 個人識別情報などの機密データが JWT に埋め込まれていないことを検証します。何らかの理由で、このような情報をトークンで送信する必要があるアーキテクチャの場合、ペイロード暗号化が適用されていることを確認します。[OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html "JSON Web Token for Java Cheat Sheet") のサンプル Java 実装を参照してください。
- リプレイ攻撃は JWT に一意の識別子を与える `jti` (JWT ID) claim で対処していることを確認します。
- KeyChain (iOS) や KeyStore (Android) などを使用して、トークンがモバイルフォンにセキュアに保存されていることを検証します。

#### ハッシュアルゴリズムの強制

攻撃者はトークンの完全性がすでに検証されていることを示すために、トークンを改変して、'none' キーワードを使用し、署名アルゴリズムを変更することを実行します。上記のリンクで説明されているように、一部のライブラリでは none アルゴリズムで署名されたトークンを検証済み署名付きの有効なトークンであるものとして扱うため、アプリケーションは改変されたトークンの claim を信頼してしまいます。

例えば、Java アプリケーションでは、検証コンテキストを作成する際に必要とされるアルゴリズムを明示的に要求する必要があります。

```java
// HMAC key - Block serialization and storage as String in JVM memory
private transient byte[] keyHMAC = ...;

//Create a verification context for the token requesting explicitly the use of the HMAC-256 HMAC generation

JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build();

//Verify the token; if the verification fails then an exception is thrown

DecodedJWT decodedToken = verifier.verify(token);
```

#### トークンの有効期限

署名されると、署名鍵が変更されない限りステートレス認証トークンは永久に有効となります。トークンの有効性を制限する一般的な方法は有効期限を設定することです。トークンに ["exp" expiration claim](https://tools.ietf.org/html/rfc7519#section-4.1.4 "RFC 7519") が含まれており、バックエンドが期限切れのトークンを処理しないことを確認します。

トークンを付与する一般的な方法は [アクセストークンとリフレッシュトークン](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/ "Refresh tokens & access tokens") を組み合わせたものです。ユーザーがログインする際、バックエンドサービスは短命の *アクセストークン* と長命の *リフレッシュトークン* を発行します。アプリケーションはアクセストークンの有効期限が切れた場合に、リフレッシュトークンを使用して新しいアクセストークンを取得できます。

機密データを処理するアプリの場合、適切な期間が経過した後にリフレッシュトークンが期限切れとなることを確認します。以下のコード例ではリフレッシュトークンの発行日をチェックするリフレッシュトークン API を示しています。トークンが 14 日以上経過していない場合、新しいアクセストークンが発行されます。そうでない場合、アクセスは拒否され、ユーザーは再度ログインするよう求められます。

```java
app.post('/renew_access_token', function (req, res) {
  // verify the existing refresh token
  var profile = jwt.verify(req.body.token, secret);

  // if refresh token is more than 14 days old, force login
  if (profile.original_iat - new Date() > 14) { // iat == issued at
    return res.send(401); // re-login
  }

  // check if the user still exists or if authorization hasn't been revoked
  if (!valid) return res.send(401); // re-logging

  // issue a new access token
  var renewed_access_token = jwt.sign(profile, secret, { expiresInMinutes: 60*5 });
  res.json({ token: renewed_access_token });
});
```

### 動的解析

動的解析を実行する中で、以下の JWT 脆弱性を調査します。

- クライアントのトークンストレージ:
  - JWT を使用するモバイルアプリのトークンストレージの場所を検証すべきです。
- 署名鍵のクラッキング:
  - トークン署名はサーバー上の秘密鍵 (private key) を介して作成されます。JWT を取得した後、[秘密鍵 (secret key) をブルートフォースによりオフラインにする](https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/ "Attacking JWT Authentication") ツールを選択します。
- 情報漏洩:
  - Base64Url でエンコードされた JWT をデコードし、送信するデータの種類とそのデータが暗号化されているかどうかを明らかにします。
- ハッシュアルゴリズムの改竄:
  - [非対称アルゴリズム](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/ "Critical Vulnerabilities in JSON Web Token") の使用。JWT は RSA や ECDSA などのいくつかの非対称アルゴリズムを提供します。これらのアルゴリズムが使用される場合、トークンは秘密鍵 (private key) で署名され、公開鍵 (public key) は検証に使用されます。サーバーはトークンが非対称アルゴリズムで署名されることを期待しており HMAC で署名されたトークンを受信する場合、サーバーは公開鍵 (public key) を HMAC 秘密鍵 (HMAC secret key) として扱います。その後、公開鍵 (public key) は悪用可能となり、トークンを署名する HMAC 秘密鍵 (HMAC secret key) として使用される可能性があります。
  - トークンヘッダーの `alg` 属性を変更し、`HS256` を削除して `none` を設定し、空の署名 (例、signature = "") を使用します。このトークンを使用して、リクエストでリプレイします。一部のライブラリでは none アルゴリズムで署名されたトークンを検証済み署名付きの有効なトークンとして扱います。これにより攻撃者は独自の「署名付き」トークンを作成できます。

上記の脆弱性をテストする際に役立つ二つの異なる Burp プラグインがあります。

- [JSON Web Token Attacker](https://portswigger.net/bappstore/82d6c60490b540369d6d5d01822bdf61 "JSON Web Token Attacker")
- [JSON Web Tokens](https://portswigger.net/bappstore/f923cbf91698420890354c1d8958fee6 "JSON Web Tokens")

また、追加情報として [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html "JSON Web Token (JWT) Cheat Sheet for Java") も確認してください。

## OAuth 2.0 フローのテスト (MSTG-AUTH-1 and MSTG-AUTH-3)

[OAuth 2.0 は API およびウェブ対応アプリケーションを横断して認可判断を伝達するデリゲーションプロトコルを定義します](https://oauth.net/articles/authentication/ "OAuth 2.0 delegation protocols") 。ユーザー認証アプリケーションを含むさまざまなアプリケーションで使用されます。

OAuth2 の一般的な用法は以下の通りです。

- ユーザーからアカウントを使用してオンラインサービスにアクセスする許可を取得すること。
- ユーザーの代わりにオンラインサービスを認証すること。
- 認証エラーを処理すること。

OAuth 2.0 によると、ユーザーのリソースにアクセスを求めるモバイルクライアントは最初に *認証サーバー* に対する認証をユーザーに要求する必要があります。ユーザーの承認を受けて、認可サーバーはトークンを発行してアプリがユーザーの代わりに動作できるようにします。OAuth2 仕様では特定の種類の認証やアクセストークンの形式を定義していないことに注意します。

OAuth 2.0 は四つのロールを定義しています。

- リソース所有者: アカウント所有者
- クライアント: アクセストークンを使用してユーザーのアカウントにアクセスしようとするアプリケーション
- リソースサーバー: ユーザーアカウントをホストします
- 認可サーバー: ユーザー識別子を検証してアプリケーションにアクセストークンを発行します

注意: API はリソース所有者と認可サーバーの両方のロールを果たします。したがって、両方を API と呼んでいます。

![OWASP MSTG](Images/Chapters/0x04e/abstract_oath2_flow.png) \

図のステップのより [詳細な説明](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2 "An Introduction into OAuth2") は以下のとおりです。

1. アプリケーションはサービスリソースにアクセスするためにユーザー認可を要求します。
2. ユーザーがリクエストを認可すると、アプリケーションは認可グラントを受け取ります。認可グラントにはいくつかの形式 (explicit, implicit, など) があります。
3. アプリケーションは認可グラントとともに独自の識別子の認証を提示することにより認可サーバー (API) からアクセストークンを要求します。
4. アプリケーション識別子が認証され認可グラントが有効である場合、認可サーバー (API) はアプリケーションにアクセストークンを発行し、認可プロセスを完了します。アクセストークンにはコンパニオンリフレッシュトークンが含まれることがあります。
5. アプリケーションはリソースサーバー (API) からリソースを要求し、認証用のアクセストークンを提示します。アクセストークンはいくつかの方法で (例えば、ベアラトークンとして) 使用される可能性があります。
6. アクセストークンが有効である場合、リソースサーバー (API) はアプリケーションにリソースを提供します。

### OAUTH 2.0 ベストプラクティス

以下のベストプラクティスに従っていることを検証します。

ユーザーエージェント:

- ユーザーは信頼性 (例、Transport Layer Security (TLS) の確認、ウェブサイトメカニズムなど) を視覚的に検証する方法を持つべきです。
- 中間者攻撃を防ぐには、クライアントは完全修飾ドメイン名を接続の確立時にサーバーが提示した公開鍵で妥当性確認すべきです。

グラント種別:

- ネイティブアプリでは、implicit グラントではなくコードグラントを使用すべきです。
- コードグラントを使用する場合、コードグラントを保護するために PKCE (Proof Key for Code Exchange) を実装すべきです。サーバーでもそれを実装していることを確認します。
- 認証 "code" は短命とすべきであり、受信後即時に使用されるべきです。認証コードは一時メモリにのみ存在し、保存やログ記録されていないことを検証します。

クライアントシークレット:

- 共有シークレットをクライアントの同一性を証明するために使用すべきではありません。クライアントは偽装される可能性があるためです ("client_id" はすでに証拠として機能しています) 。クライアントシークレットを使用する場合には、それらがセキュアなローカルストレージに保存されていることを確認します。

エンドユーザー資格情報:

- TLS など、トランスポート層の手法を使用してエンドユーザー資格情報の送信を保護します。

トークン:

- アクセストークンを一時メモリに保持します。
- アクセストークンは暗号化された接続の上で送信する必要があります。
- エンドツーエンドの機密性が保証できない場合、またはトークンが機密情報やトランザクションへのアクセスを提供する場合、アクセストークンのスコープと期間を狭めます。
- アプリがアクセストークンをベアラトークンとして使用し、他にクライアントを特定する方法がない場合、トークンを盗み出した攻撃者はそれらに関連付けられたスコープとすべてのリソースにアクセスできることに注意します。
- リフレッシュトークンをセキュアなローカルストレージに保存します。これらは長期的な資格情報です。

#### 外部ユーザーエージェントと埋め込みユーザーエージェント

OAuth2 認証は外部ユーザーエージェント (Chrome や Safari など) を介して、またはアプリ自身 (アプリに埋め込まれた WebView や認証ライブラリなど) 内で実行できます。二つのモードは本質的にいずれかが「より優れて」いるわけではありません。それよりも、選択するモードはコンテキストに依存します。

*外部ユーザーエージェント* を使用することはソーシャルメディアアカウント (Facebook, Twitter, など) とやり取りする必要があるアプリに適した方法です。この方法の利点は以下の通りです。

- ユーザーの資格情報はアプリに直接開示されることはありません。これによりアプリがログインプロセス時に資格情報を取得 (「資格情報フィッシング」) できないことを保証します。

- アプリ自体に認証ロジックを追加する必要はほとんどないため、コーディングエラーを防止します。

欠点としては、ブラウザの動作を制御する方法がないことがあげられます (例えば、証明書ピンニングをアクティブにするなど) 。

閉じたエコシステム内で動作するアプリでは、*埋め込み認証* のほうが適しています。例えば、OAuth2 を使用して銀行の認証サーバーからアクセストークンを取得する銀行アプリを考えてみます。この認証サーバーは多くのマイクロサービスへのアクセスに使用されます。その場合、資格情報フィッシングは実行可能なシナリオではありません。外部コンポーネントに信頼を置くのではなく、(願わくは) 慎重にセキュリティ保護された銀行アプリで認証プロセスを維持することをお勧めします。

### その他の OAuth2 ベストプラクティス

追加のベストプラクティスと詳細情報については以下のソースドキュメントを参照してください。

- [RFC6749 - The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749 "RFC6749: The OAuth 2.0 Authorization Framework (October 2012)")
- [DRAFT - OAuth 2.0 for Native Apps](https://tools.ietf.org/html/draft-ietf-oauth-native-apps-12 "draft_ietf-oauth-native-apps-12: OAuth 2.0 for Native Apps (June 2017)")
- [RFC6819 - OAuth 2.0 Threat Model and Security Considerations](https://tools.ietf.org/html/rfc6819 "RFC6819: OAuth 2.0 Threat Model and Security Considerations (January 2013)")

## ログインアクティビティとデバイスブロッキングのテスト (MSTG-AUTH-11)

L2 保護を必要とするアプリケーションでは、MASVS は特定のデバイスをブロックする可能性のあるアプリ内のすべてのログインアクティビティについてユーザーに通知すべきであると述べています。これはさまざまなシナリオに分類できます。

1. アプリケーションは異なるアクティビティをユーザーに通知するためにアカウントが別のデバイスで使用されたときにプッシュ通信を提供します。ユーザーはプッシュ通知を介してアプリを開いた後にこのデバイスをブロックできます。
2. アプリケーションはログイン後の最後のセッションの概要を提供します。前のセッションが現在の構成と比較して異なる構成 (例、位置情報、デバイス、アプリバージョン) の場合、ユーザーは疑わしいアクティビティを報告し、前のセッションで使用されたデバイスをブロックするオプションを持つべきです。
3. アプリケーションはログイン後の最後のセッションの概要を常に提供します。
4. アプリケーションはユーザーが監査ログを参照できるセルフサービスポータルを持ちます。これによりユーザーはログインしているさまざまなデバイスを管理できます。

開発者は特定のメタ情報を使用してアプリケーション内のさまざまなアクティビティやイベントを関連付けることができます。これによりユーザーは疑わしい動作を見つけやすくなり、該当するデバイスをブロックしやすくなります。メタ情報には以下のものがあります。

- デバイス: ユーザーはアプリが使用されているすべてのデバイスを明確に識別できます。
- 日付と時刻: ユーザーはアプリが使用された最新の日付と時刻を明確に参照できます。
- 位置情報: ユーザーはアプリが使用された最新の位置情報を明確に識別できます。

アプリケーションはアプリケーション内のそれぞれの機密性の高いアクティビティの後に更新されるアクティビティ履歴のリストを提供できます。監査するアクティビティの選択は処理するデータとチームが許容するセキュリティリスクのレベルに基づいてアプリケーションごとに行う必要があります。下記は通常監査される一般的な機密性の高いアクティビティのリストです。

- ログイン試行
- パスワード変更
- 個人識別情報変更 (名前、電子メールアドレス、電話番号、など)
- 機密性の高いアクティビティ (購入、重要なリソースへのアクセス、など)
- 利用規約条項への同意

有料コンテンツには特に注意が必要であり、追加のメタ情報 (例、費用、クレジット、など) を使用して操作全体のパラメータに関するユーザーの知識を確保します。

さらに、特定のトランザクションが実際に (完全性) および誰により (真正性) 実行されたかを証明するために、否認防止メカニズムを機密性の高いトランザクション (例、有料コンテンツアクセス、利用規約条項への同意、など) に適用すべきです。

すべての場合において、異なるデバイスが正しく検出されているかどうかを検証すべきです。したがって、アプリケーションを実際のデバイスにバインディングするテストをすべきです。
iOS では、開発者はバンドル ID に関連する `identifierForVendor` を使用できます。バンドル ID を変更すると、このメソッドは異なる値を返します。アプリを始めて実行した際、`identifierForVendor` により返された値を KeyChain に保存することを確認します。これにより変更は早い段階で検出できます。

Android では、開発者は Android 8.0 (API レベル 26) まで `Settings.Secure.ANDROID_ID` を使用してアプリケーションインスタンスを識別できます。Android 8.0 (API レベル 26) 以降、`ANDROID_ID` はデバイス固有 ID ではないことに注意します。代わりに、アプリ署名鍵、ユーザーおよびデバイスの組み合わせによりスコープが設定されます。そのためこれらの Android バージョンではデバイスブロッキングに対して `ANDROID_ID` を妥当性確認することは困難となることがあります。アプリが署名鍵を変更した場合、`ANDROID_ID` が変更され古いユーザーのデバイスを認識できなくなるためです。したがって、`AndroidKeyStore` からランダムに生成された鍵と、できれば AES_GCM 暗号化を使用して、暗号化された `ANDROID_ID` をプライベートな共有リファレンスにプライベートに保存することをお勧めします。アプリ署名が変更された際に、アプリケーションはデルタをチェックし新しい  `ANDROID_ID` を登録できます。新しいアプリケーション署名鍵なしでこの新しい ID が変更された場合、他の何かが間違いであることを示すべきです。
次に、iOS の `Keychain` および Android の `KeyStore` に保存された鍵でリクエストに署名することによりデバイスバインディングを拡張でき、強力なデバイスバインディングを再保証できます。
また、さまざまな IP 、さまざまな位置情報やさまざまなタイムスロットを使用して、すべてのシナリオで適切なタイプの情報がトリガーされるかどうかをテストすべきです。

最後に、アプリの登録済みインスタンスをブロックし、認証が許可されなくなることを確認して、デバイスのブロッキングをテストすべきです。
注意: L2 保護を必要とするアプリケーションの場合、新しいデバイスでの最初の認証を行う前でもユーザーに警告することをお勧めします。代わりとして、アプリの二番目のインスタンスが登録された際にユーザーに警告します。

## 参考情報

### OWASP MASVS

- MSTG-ARCH-2: "セキュリティコントロールはクライアント側だけではなくそれぞれのリモートエンドポイントで実施されている。"
- MSTG-AUTH-1: "アプリがユーザーにリモートサービスへのアクセスを提供する場合、ユーザー名/パスワード認証など何らかの形態の認証がリモートエンドポイントで実行されている。"
- MSTG-AUTH-2: "ステートフルなセッション管理を使用する場合、リモートエンドポイントはランダムに生成されたセッション識別子を使用し、ユーザーの資格情報を送信せずにクライアントリクエストを認証している。"
- MSTG-AUTH-3: "ステートレスなトークンベースの認証を使用する場合、サーバーはセキュアなアルゴリズムを使用して署名されたトークンを提供している。"
- MSTG-AUTH-4: "ユーザーがログアウトする際に、リモートエンドポイントは既存のセッションを終了している。"
- MSTG-AUTH-5: "パスワードポリシーが存在し、リモートエンドポイントで実施されている。"
- MSTG-AUTH-6: "リモートエンドポイントは過度な資格情報の送信に対する保護を実装している。"
- MSTG-AUTH-7: "事前に定義された非アクティブ期間およびアクセストークンの有効期限が切れた後に、セッションはリモートエンドポイントで無効にしている。"
- MSTG-AUTH-9: "リモートエンドポイントに二要素認証が存在し、リモートエンドポイントで二要素認証要件が一貫して適用されている。"
- MSTG-AUTH-10: "機密トランザクションはステップアップ認証を必要としている。"
- MSTG-AUTH-11: "アプリはユーザーのアカウントでのすべての機密アクティビティをユーザーに通知している。ユーザーはデバイスの一覧を表示したり、コンテキスト情報 (IP アドレス、位置情報など) を表示したり、特定のデバイスをブロックすることができる。"

#### SMS-OTP Research

- [#dmitrienko] Dmitrienko, Alexandra, et al. "On the (in) security of mobile two-factor authentication." International Conference on Financial Cryptography and Data Security. Springer, Berlin, Heidelberg, 2014.
- [#grassi] Grassi, Paul A., et al. Digital identity guidelines: Authentication and lifecycle management (DRAFT). No. Special Publication (NIST SP)-800-63B. 2016.
- [#grassi2] Grassi, Paul A., et al. Digital identity guidelines: Authentication and lifecycle management. No. Special Publication (NIST SP)-800-63B. 2017.
- [#konoth] Konoth, Radhesh Krishnan, Victor van der Veen, and Herbert Bos. "How anywhere computing just killed your phone-based two-factor authentication." International Conference on Financial Cryptography and Data Security. Springer, Berlin, Heidelberg, 2016.
- [#mulliner] Mulliner, Collin, et al. "SMS-based one-time passwords: attacks and defense." International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment. Springer, Berlin, Heidelberg, 2013.
- [#siadati] Siadati, Hossein, et al. "Mind your SMSes: Mitigating social engineering in second factor authentication." Computers & Security 65 (2017): 14-28.
- [#siadati2] Siadati, Hossein, Toan Nguyen, and Nasir Memon. "Verification code forwarding attack (short paper)." International Conference on Passwords. Springer, Cham, 2015.
